# 다이나믹 프로그래밍

## 1. 중복되는 연산을 줄이자
- 개념
    - 다이나믹 프로그래밍은 최적의 해를 구하기 위해서 작은 문제부터 해결하여 결과값을 재사용하는 방식이다.
    - 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.

- 다이나믹 프로그래밍 vs 퀵 정렬
    - 공통점
        - 둘 다 분할 정복(Divide and Conquer) 알고리즘의 일종이다
        - 복잡한 문제를 작은 하위 문제로 나누어 해결하는 방식을 사용한다
    - 차이점
        1. **부분 문제의 중복**
        - 다이나믹 프로그래밍: 부분 문제들이 서로 중복되어 나타남
        - 퀵 정렬: 부분 문제들이 서로 독립적이며 중복되지 않음

        2. **문제 해결 방식**
        - 다이나믹 프로그래밍: 중복되는 부분 문제의 결과를 저장하고 재활용
        - 퀵 정렬: 독립적인 부분 문제를 각각 정렬하고 병합

## 2. 피보나치 수열로 알아보는 다이나믹 프로그래밍
- 피보나치 수열의 점화식: an+2 = f(an+1, an) = an+1 + an

- 피보나치 수열에서 재귀의 문제점
    - 재귀적으로 구현한 피보나치 수열은 같은 함수가 반복적으로 호출되어 비효율적이다.
    - 시간복잡도가 O(2^N)으로 매우 비효율적이다.

```python
# 비효율적인 피보나치 함수 소스코드
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)
```
- 비효율적인 이유
    - 같은 값을 반복적으로 계산하기 때문입니다. 예를 들어 fibo(6)을 계산할 때:
        - fibo(6)을 계산하기 위해 fibo(5)와 fibo(4)를 계산
        - fibo(5)를 계산하기 위해 fibo(4)와 fibo(3)을 계산
        - fibo(4)를 계산하기 위해 fibo(3)과 fibo(2)를 계산
        - fibo(6) 계산 과정:
            ```
                                fibo(6)
                                /          \
                        fibo(5)             fibo(4)
                    /        \          /        \
                fibo(4)     fibo(3)   fibo(3)   fibo(2)
                /      \      /    \    /    \      |
            fibo(3) fibo(2) fibo(2) fibo(1) ...    return 1
            ```

## 3. 다이나믹 프로그래밍의 두 가지 방식
1) 메모이제이션 (하향식)
- 개념: 한 번 계산한 결과를 메모리 공간에 메모해두고 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져오는 기법
- 사용
    - 큰 문제를 작은 문제로 나눌 수 있어야 함
    - 작은 문제의 해결 방법이 큰 문제에서도 동일하게 적용되어야 함
    - 예시: 피보나치 수열에서 f(n) = f(n-1) + f(n-2)라는 동일한 구조가 계속 적용됨
- 메모이제이션은 값을 저장하는 방법 이므로 캐싱(Caching)이라고도 한다
- 시간복잡도: O(N)


```python
# 메모이제이션 기법을 사용한 피보나치 수열
d = [0] * 100  # 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화

def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]
```

2) 반복문 (상향식)
- 단순히 반복문을 이용하여 소스코드를 작성하는 방식
- 작은 문제부터 차근차근 답을 도출하는 방식

```python
# 반복문으로 구현한 피보나치 수열
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]
```

# 4. 코딩테스트 꿀팁

## 1. 리스트와 딕셔너리 활용
- 메모이제이션 구현 시 리스트뿐만 아니라 딕셔너리(dict) 자료형도 사용 가능
- 딕셔너리는 수열처럼 연속적이지 않은 경우에 유용
- 예시: ai를 계산하고자 할 때 a(i) - a(j) 모두가 아닌 일부의 작은 문제에 대한 해답만 필요한 경우

## 2. 다른 알고리즘과의 조합
- 다이나믹 프로그래밍 문제가 항상 단순하지 않을 수 있음
- 다른 알고리즘과 결합하여 해결해야 하는 경우가 있음
- 특히 "플로이드 워셜" 알고리즘과 같은 특수한 다이나믹 프로그래밍 유형 존재

## 3. 코딩 테스트 문제 유형
- 코딩 테스트에서는 대체로 간단한 형태로 출제
- 다만 높은 난이도의 문제에서는 다른 알고리즘과의 복합적인 구현이 필요할 수 있음

## 4. 재귀 함수 사용 시 주의사항
- 재귀 제한이 있는 경우, sys 라이브러리의 setrecursionlimit() 함수를 사용하여 제한을 완화
- 재귀적 피보나치 수열의 스택 크기가 한정되어 있을 수 있음을 주의
- 실제 구현 시에는 가급적 내장 함수나 반복문을 사용하는 것이 안전

## 5. 문제 해결 접근법
1. 문제를 푸는 첫 번째 단계는 다이나믹 프로그래밍 유형임을 파악
2. 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 오래 걸린다면 다이나믹 프로그래밍을 적용
3. 일단 완전 탐색으로 접근 후, 중복되는 부분을 찾아 메모이제이션 적용을 고려